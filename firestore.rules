/**
 * This ruleset enforces a security model for the AdZone Lanka application.
 *
 * Core Philosophy:
 * The ruleset follows a "public read, owner-only write" model for shared content like ads,
 * comments, and likes. User-specific data (profiles, payments, memberships) is strictly
 * private and accessible only by the owning user. Publicly shared, static data like
 * categories and banners are read-only for all users to ensure data integrity.
 *
 * Data Structure:
 * The data is organized into several top-level collections: /users, /ads, /categories,
 * /memberships, /banners, and /payments. The /ads collection contains nested subcollections
 * for /comments and /likes to maintain a clear relational structure.
 *
 * Key Security Decisions:
 * - User data in /users/{userId} is strictly private to the authenticated owner.
 * - Ads, categories, and active banners are publicly readable by anyone, including
 *   unauthenticated users, to support the app's browsing functionality.
 * - All write operations (create, update, delete) are restricted. Users must be authenticated
 *   to create content, and can only modify or delete content they own.
 * - Static content collections (/categories) and admin-managed content (/banners)
 *   are locked down; writes are disallowed from the client-side to be managed by a
 *   trusted backend process.
 * - Listing documents from private collections like /payments and /memberships is disallowed
 *   to prevent data leakage. Users must know the specific document ID to fetch their data.
 *
 * Denormalization for Authorization:
 * To ensure fast and secure access control, an ownership field (typically 'userId') is
 * denormalized onto documents like ads, comments, likes, payments, and memberships. This
 * allows rules to authorize requests by inspecting the document's data directly, avoiding
 * slow and costly 'get()' calls to other documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for common authorization logic.
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    // Check if the user owns the document being accessed (for read operations).
    function isDocumentOwner(doc) {
      return isSignedIn() && request.auth.uid == doc.data.userId;
    }

    // Check ownership for a write operation where the document already exists.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Check ownership for a create operation.
    function isCreatingOwner() {
      return isSignedIn() && request.resource.data.userId == request.auth.uid;
    }
    
    // Check if a field is unchanged during an update.
    function isFieldUnchanged(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }

    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isFieldUnchanged('id');
      allow delete: if isOwner(userId);
    }

    match /ads/{adId} {
      allow get, list: if true;
      allow create: if isCreatingOwner();
      allow update: if isOwner(resource.data.userId) && isFieldUnchanged('userId') && isFieldUnchanged('adId');
      allow delete: if isOwner(resource.data.userId);
    }

    match /categories/{categoryId} {
      allow get, list: if true;
      allow write: if false; // Categories are managed by backend, not clients.
    }

    match /memberships/{membershipId} {
      allow get: if isDocumentOwner(get(/databases/$(database)/documents/memberships/$(membershipId)));
      allow list: if false; // Prevent listing all memberships.
      allow create: if isCreatingOwner();
      allow update: if isOwner(resource.data.userId) && isFieldUnchanged('userId');
      allow delete: if isOwner(resource.data.userId);
    }

    match /banners/{bannerId} {
      allow get, list: if resource.data.status == 'Active' && resource.data.expiryDate > request.time;
      // Admin-only write access is implied by 'allow write: if false' and handled by backend.
      allow write: if false;
    }

t
    match /payments/{paymentId} {
      allow get: if isDocumentOwner(get(/databases/$(database)/documents/payments/$(paymentId)));
      allow list: if false; // Prevent listing all payments.
      allow create: if isCreatingOwner() && request.resource.data.status == 'Pending';
      // Do not allow clients to approve their own payments or change payment details.
      allow update, delete: if false; 
    }

    match /ads/{adId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isCreatingOwner() && request.resource.data.adId == adId;
      allow update: if isOwner(resource.data.userId) && isFieldUnchanged('userId') && isFieldUnchanged('adId');
      allow delete: if isOwner(resource.data.userId);
    }

    match /ads/{adId}/likes/{likeId} {
      allow get, list: if true;
      // A user can only create a like for themselves on a specific ad.
      allow create: if isCreatingOwner() && request.resource.data.adId == adId;
      allow update: if false; // Likes are not updatable.
      // A user can only delete their own like.
      allow delete: if isOwner(resource.data.userId);
    }
  }
}
