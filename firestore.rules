/**
 * This ruleset enforces a security model for the AdZone Lanka application.
 *
 * Core Philosophy:
 * The ruleset follows a "public read, owner-only write" model for shared content like ads,
 * comments, and likes. User-specific data (profiles, payments, memberships) is strictly
 * private and accessible only by the owning user. Publicly shared, static data like
 * categories and banners are read-only for all users to ensure data integrity. Admin-level
 * actions, like approving payments, are restricted to users with an `isAdmin` flag.
 *
 * Data Structure:
 * The data is organized into several top-level collections: /users, /ads, /categories,
 * /memberships, /banners, and /payments. The /ads collection contains nested subcollections
 * for /comments and /likes to maintain a clear relational structure.
 *
 * Key Security Decisions:
 * - User data in /users/{userId} is strictly private to the authenticated owner, but readable
 *   by admins.
 * - Ads, categories, and active banners are publicly readable by anyone.
 * - All write operations (create, update, delete) are restricted. Users must be authenticated
 *   to create content, and can only modify or delete content they own. Admins have broader
 *   modification rights.
 * - Static content collections (/categories) are locked down from client-side writes.
 * - Payments can only be created by the user, but only updated (e.g., approved/rejected) by an admin.
 *
 * Denormalization for Authorization:
 * To ensure fast and secure access control, an ownership field (typically 'userId') is
 * denormalized onto documents. This allows rules to authorize requests by inspecting the
 * document's data directly, avoiding slow and costly 'get()' calls to other documents.
 * The `isAdmin` flag on a user's document is used for privileged access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for common authorization logic.
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAdmin() {
      // Check if the requesting user's document has the `isAdmin` flag set to true.
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }
    
    // Check if the user owns the document being accessed (for read operations).
    function isDocumentOwner(doc) {
      return isSignedIn() && request.auth.uid == doc.data.userId;
    }

    // Check ownership for a write operation where the document already exists.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Check ownership for a create operation.
    function isCreatingOwner() {
      return isSignedIn() && request.resource.data.userId == request.auth.uid;
    }
    
    // Check if a field is unchanged during an update.
    function isFieldUnchanged(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }

    match /users/{userId} {
      allow get, list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isFieldUnchanged('id');
      allow delete: if isOwner(userId) || isAdmin();
    }

    match /ads/{adId} {
      allow get, list: if true;
      allow create: if isCreatingOwner();
      allow update: if isOwner(resource.data.userId) && isFieldUnchanged('userId') && isFieldUnchanged('id');
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }

    match /categories/{categoryId} {
      allow get, list: if true;
      allow write: if false; // Categories are managed by backend, not clients.
    }

    match /memberships/{membershipId} {
      allow get: if isDocumentOwner(get(/databases/$(database)/documents/memberships/$(membershipId))) || isAdmin();
      allow list: if isAdmin(); // Only admins can list all memberships.
      allow create: if isCreatingOwner();
      allow update: if (isOwner(resource.data.userId) && isFieldUnchanged('userId')) || isAdmin();
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }

    match /banners/{bannerId} {
      allow get, list: if true; // Banners are publicly visible
      allow write: if isAdmin(); // Only admins can create, update, or delete banners.
    }

    match /payments/{paymentId} {
      allow get, list: if isDocumentOwner(get(/databases/$(database)/documents/payments/$(paymentId))) || isAdmin();
      allow create: if isCreatingOwner() && request.resource.data.status == 'Pending';
      // Only admins can update payments (e.g., to approve or reject them).
      allow update: if isAdmin(); 
      allow delete: if isAdmin();
    }

    match /ads/{adId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isCreatingOwner() && request.resource.data.adId == adId;
      allow update: if isOwner(resource.data.userId) && isFieldUnchanged('userId') && isFieldUnchanged('adId');
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }

    match /ads/{adId}/likes/{likeId} {
      allow get, list: if true;
      // A user can only create a like for themselves on a specific ad.
      allow create: if isCreatingOwner() && request.resource.data.adId == adId;
      allow update: if false; // Likes are not updatable.
      // A user can only delete their own like.
      allow delete: if isOwner(resource.data.userId);
    }
  }
}
